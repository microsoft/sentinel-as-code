AlertRuleTemplateName: 
Id: f89b0a15-30fa-4cd8-b485-49266924910f
Enabled: true
DisplayName: Detect brute force login attempts with geographic information.
Description: ""
Query: "let lookback = 1d;\r\nlet fl_Min = 3;\r\nlet un_MatchMin = 2;\r\nlet upnFunc = (startTimeSpan:timespan, tableName:string){\r\ntable(tableName) | where TimeGenerated >= ago(lookback)\r\n| extend Operation = columnifexists(\"Operation\", \"Sign-in activity\")\r\n| where Operation == \"UserLoginFailed\" or Operation == \"Sign-in activity\"\r\n| extend Result = columnifexists(\"ResultType\", \"tempValue\")\r\n| extend Result = iff(Result == \"tempValue\", columnifexists(\"ResultStatus\", Result), Result)\r\n| extend ResultValue = case(Result == \"0\", \"Success\", Result == \"Success\" or Result == \"Succeeded\", \"Success\", Result)\r\n| where ResultValue != \"Success\"\r\n| extend UserPrincipalName = columnifexists(\"UserPrincipalName\", \"tempValue\") \r\n| extend UserPrincipalName = iff(tableName == \"OfficeActivity\", tolower(UserId), tolower(UserPrincipalName))\r\n| extend UPN = split(UserPrincipalName, \"@\")\r\n| extend UserNameOnly = tostring(UPN[0]), DomainOnly = tostring(UPN[1])\r\n| where UserNameOnly contains \".\" or UserPrincipalName contains \"-\" or UserPrincipalName contains \"_\"\r\n// Verify we only get accounts without other separators, it would be difficult to identify multi-level separators\r\n// Count of any that are not alphanumeric\r\n| extend charcount = countof(UserNameOnly, '[^0-9A-Za-z]', \"regex\")\r\n// Drop any that have non-alphanumeric characters still included\r\n| where charcount < 2\r\n// Creating array of name pairs that include the separators we are interested in, this can be added to if needed.\r\n| extend unoArray = case(\r\nUserNameOnly contains \".\", split(UserNameOnly, \".\"),\r\nUserNameOnly contains \"-\", split(UserNameOnly, \"-\"),\r\nUserNameOnly contains \"_\", split(UserNameOnly, \"_\"),\r\nUserNameOnly)\r\n| extend First = iff(isnotempty(tostring(parsejson(unoArray)[0])), tostring(parsejson(unoArray)[0]),tostring(unoArray))\r\n| extend Last = tostring(parsejson(unoArray)[1])\r\n| extend First4char = iff(countof(substring(First, 0,4), '[0-9A-Za-z]', \"regex\") >= 4, substring(First, 0,4), \"LessThan4\"),\r\nFirst6char = iff(countof(substring(First, 0,6), '[0-9A-Za-z]', \"regex\") >= 6, substring(First, 0,6), \"LessThan6\"),\r\nFirst8char = iff(countof(substring(First, 0,8), '[0-9A-Za-z]', \"regex\") >= 8, substring(First, 0,8), \"LessThan8\"),\r\nLast4char = iff(countof(substring(Last, 0,4), '[0-9A-Za-z]', \"regex\") >= 4, substring(Last, 0,4), \"LessThan4\"),\r\nLast6char = iff(countof(substring(Last, 0,6), '[0-9A-Za-z]', \"regex\") >= 6, substring(Last, 0,6), \"LessThan6\"),\r\nLast8char = iff(countof(substring(Last, 0,8), '[0-9A-Za-z]', \"regex\") >= 8, substring(Last, 0,8), \"LessThan8\")\r\n| where First != Last\r\n| summarize UserNames = makeset(UserNameOnly),\r\nfl_Count = count() by bin(TimeGenerated, 10m), First4char, First6char, First8char, Last4char, Last6char, Last8char, Type\r\n};\r\nlet SigninList = upnFunc(lookback,\"SigninLogs\");\r\nlet OffActList = upnFunc(lookback,\"OfficeActivity\");\r\nlet UserNameList = (union isfuzzy=true SigninList, OffActList);\r\nlet Char4List = UserNameList\r\n| project TimeGenerated, First4char, Last4char, UserNames, fl_Count, Type\r\n| where First4char != \"LessThan4\" and Last4char != \"LessThan4\";\r\n// Break out first and last so we can then join and see where a first and last match.\r\nlet First4charList = Char4List | where isnotempty(First4char)\r\n| summarize un_MatchOnFirst = makeset(UserNames),\r\nfl_CountForFirst = sum(fl_Count) by TimeGenerated, CharSet = First4char, Type\r\n| project TimeGenerated, CharSet, un_MatchOnFirst, un_MatchOnFirstCount = array_length(un_MatchOnFirst), fl_CountForFirst, Type;\r\nlet Last4charList = Char4List | where isnotempty(Last4char) \r\n| summarize un_MatchOnLast = makeset(UserNames), fl_CountForLast = sum(fl_Count) by TimeGenerated, CharSet = Last4char, Type\r\n| project TimeGenerated, CharSet, un_MatchOnLast, un_MatchOnLastCount = array_length(un_MatchOnLast), fl_CountForLast, Type;\r\nlet char4 = First4charList | join Last4charList on CharSet and TimeGenerated\r\n| project-away TimeGenerated1, CharSet1\r\n// Make sure that we get more than a single match for First or Last\r\n| where un_MatchOnFirstCount >= un_MatchMin or un_MatchOnLastCount >= un_MatchMin\r\n| where fl_CountForFirst >= fl_Min or fl_CountForLast >= fl_Min;\r\nlet Char6List = UserNameList\r\n| project TimeGenerated, First6char, Last6char, UserNames, fl_Count, Type\r\n| where First6char != \"LessThan6\" and Last6char != \"LessThan6\";\r\n// Break out first and last so we can then join and see where a first and last match.\r\nlet First6charList = Char6List | where isnotempty(First6char)\r\n| summarize un_MatchOnFirst = makeset(UserNames), fl_CountForFirst = sum(fl_Count) by TimeGenerated, CharSet = First6char, Type\r\n| project TimeGenerated, CharSet, un_MatchOnFirst, un_MatchOnFirstCount = array_length(un_MatchOnFirst), fl_CountForFirst, Type;\r\nlet Last6charList = Char6List | where isnotempty(Last6char)\r\n| summarize un_MatchOnLast = makeset(UserNames), fl_CountForLast = sum(fl_Count) by TimeGenerated, CharSet = Last6char, Type\r\n| project TimeGenerated, CharSet, un_MatchOnLast, un_MatchOnLastCount = array_length(un_MatchOnLast), fl_CountForLast, Type;\r\nlet char6 = First6charList | join Last6charList on CharSet and TimeGenerated\r\n| project-away TimeGenerated1, CharSet1\r\n// Make sure that we get more than a single match for First or Last\r\n| where un_MatchOnFirstCount >= un_MatchMin or un_MatchOnLastCount >= un_MatchMin\r\n| where fl_CountForFirst >= fl_Min or fl_CountForLast >= fl_Min;\r\nlet Char8List = UserNameList\r\n| project TimeGenerated, First8char, Last8char, UserNames, fl_Count, Type\r\n| where First8char != \"LessThan8\" and Last8char != \"LessThan8\";\r\n// Break out first and last so we can then join and see where a first and last match.\r\nlet First8charList = Char8List | where isnotempty(First8char)\r\n| summarize un_MatchOnFirst = makeset(UserNames), fl_CountForFirst = sum(fl_Count) by TimeGenerated, CharSet = First8char, Type\r\n| project TimeGenerated, CharSet, un_MatchOnFirst, un_MatchOnFirstCount = array_length(un_MatchOnFirst), fl_CountForFirst, Type; \r\nlet Last8charList = Char8List | where isnotempty(Last8char)\r\n| summarize un_MatchOnLast = makeset(UserNames), fl_CountForLast = sum(fl_Count) by TimeGenerated, CharSet = Last8char, Type\r\n| project TimeGenerated, CharSet, un_MatchOnLast, un_MatchOnLastCount = array_length(un_MatchOnLast), fl_CountForLast, Type;\r\nlet char8 = First8charList | join Last8charList on CharSet and TimeGenerated\r\n| project-away TimeGenerated1, CharSet1\r\n// Make sure that we get more than a single match for First or Last\r\n| where un_MatchOnFirstCount >= un_MatchMin or un_MatchOnLastCount >= un_MatchMin\r\n| where fl_CountForFirst >= fl_Min or fl_CountForLast >= fl_Min;\r\n(union isfuzzy=true char4, char6, char8)\r\n| project Type, TimeGenerated, CharSet, UserNameMatchOnFirst = un_MatchOnFirst, UserNameMatchOnFirstCount = un_MatchOnFirstCount,\r\nFailedLogonCountForFirst = fl_CountForFirst, UserNameMatchOnLast = un_MatchOnLast, UserNameMatchOnLastCount = un_MatchOnLastCount,\r\nFailedLogonCountForLast = fl_CountForLast\r\n| sort by UserNameMatchOnFirstCount desc, UserNameMatchOnLastCount desc\r\n| extend timestamp = TimeGenerated\r\n"
SeveritiesFilter: 
Severity: High
QueryFrequency: PT5M
QueryPeriod: PT5M
TriggerOperator: GreaterThan
TriggerThreshold: 1
Tactics:
- InitialAccess
EventGroupSettings:
  aggregationKind: SingleAlert
SuppressionDuration: PT5H
SuppressionEnabled: false
IncidentConfiguration:
  createIncident: true
  groupingConfiguration:
    enabled: true
    reopenClosedIncident: false
    lookbackDuration: PT5M
    entitiesMatchingMethod: All
    groupByEntities: []
EntityMappings: 
Kind: Scheduled
