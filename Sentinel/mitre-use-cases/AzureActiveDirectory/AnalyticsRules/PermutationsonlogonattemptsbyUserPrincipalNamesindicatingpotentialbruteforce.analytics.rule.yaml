AlertRuleTemplateName: 
Id: 246df383-b56d-4cfc-b085-a8f08d3edf6a
Enabled: true
DisplayName: Permutations on logon attempts by UserPrincipalNames indicating potential brute force
Description: Permutations on logon attempts by UserPrincipalNames indicating potential brute force
Query: "let lookback = 1d;\nlet fl_Min = 3;\nlet un_MatchMin = 2;\nlet upnFunc = (startTimeSpan:timespan, tableName:string){\ntable(tableName) | where TimeGenerated >= ago(lookback)\n| extend Operation = columnifexists(\"Operation\", \"Sign-in activity\")\n| where Operation == \"UserLoginFailed\" or Operation == \"Sign-in activity\"\n| extend Result = columnifexists(\"ResultType\", \"tempValue\")\n| extend Result = iff(Result == \"tempValue\", columnifexists(\"ResultStatus\", Result), Result)\n| extend ResultValue = case(Result == \"0\", \"Success\", Result == \"Success\" or Result == \"Succeeded\", \"Success\", Result)\n| where ResultValue != \"Success\"\n| extend UserPrincipalName = columnifexists(\"UserPrincipalName\", \"tempValue\") \n| extend UserPrincipalName = iff(tableName == \"OfficeActivity\", tolower(UserId), tolower(UserPrincipalName))\n| extend UPN = split(UserPrincipalName, \"@\")\n| extend UserNameOnly = tostring(UPN[0]), DomainOnly = tostring(UPN[1])\n| where UserNameOnly contains \".\" or UserPrincipalName contains \"-\" or UserPrincipalName contains \"_\"\n// Verify we only get accounts without other separators, it would be difficult to identify multi-level separators\n// Count of any that are not alphanumeric\n| extend charcount = countof(UserNameOnly, '[^0-9A-Za-z]', \"regex\")\n// Drop any that have non-alphanumeric characters still included\n| where charcount < 2\n// Creating array of name pairs that include the separators we are interested in, this can be added to if needed.\n| extend unoArray = case(\nUserNameOnly contains \".\", split(UserNameOnly, \".\"),\nUserNameOnly contains \"-\", split(UserNameOnly, \"-\"),\nUserNameOnly contains \"_\", split(UserNameOnly, \"_\"),\nUserNameOnly)\n| extend First = iff(isnotempty(tostring(parsejson(unoArray)[0])), tostring(parsejson(unoArray)[0]),tostring(unoArray))\n| extend Last = tostring(parsejson(unoArray)[1])\n| extend First4char = iff(countof(substring(First, 0,4), '[0-9A-Za-z]', \"regex\") >= 4, substring(First, 0,4), \"LessThan4\"),\nFirst6char = iff(countof(substring(First, 0,6), '[0-9A-Za-z]', \"regex\") >= 6, substring(First, 0,6), \"LessThan6\"),\nFirst8char = iff(countof(substring(First, 0,8), '[0-9A-Za-z]', \"regex\") >= 8, substring(First, 0,8), \"LessThan8\"),\nLast4char = iff(countof(substring(Last, 0,4), '[0-9A-Za-z]', \"regex\") >= 4, substring(Last, 0,4), \"LessThan4\"),\nLast6char = iff(countof(substring(Last, 0,6), '[0-9A-Za-z]', \"regex\") >= 6, substring(Last, 0,6), \"LessThan6\"),\nLast8char = iff(countof(substring(Last, 0,8), '[0-9A-Za-z]', \"regex\") >= 8, substring(Last, 0,8), \"LessThan8\")\n| where First != Last\n| summarize UserNames = makeset(UserNameOnly),\nfl_Count = count() by bin(TimeGenerated, 10m), First4char, First6char, First8char, Last4char, Last6char, Last8char, Type\n};\nlet SigninList = upnFunc(lookback,\"SigninLogs\");\nlet OffActList = upnFunc(lookback,\"OfficeActivity\");\nlet UserNameList = (union isfuzzy=true SigninList, OffActList);\nlet Char4List = UserNameList\n| project TimeGenerated, First4char, Last4char, UserNames, fl_Count, Type\n| where First4char != \"LessThan4\" and Last4char != \"LessThan4\";\n// Break out first and last so we can then join and see where a first and last match.\nlet First4charList = Char4List | where isnotempty(First4char)\n| summarize un_MatchOnFirst = makeset(UserNames),\nfl_CountForFirst = sum(fl_Count) by TimeGenerated, CharSet = First4char, Type\n| project TimeGenerated, CharSet, un_MatchOnFirst, un_MatchOnFirstCount = array_length(un_MatchOnFirst), fl_CountForFirst, Type;\nlet Last4charList = Char4List | where isnotempty(Last4char) \n| summarize un_MatchOnLast = makeset(UserNames), fl_CountForLast = sum(fl_Count) by TimeGenerated, CharSet = Last4char, Type\n| project TimeGenerated, CharSet, un_MatchOnLast, un_MatchOnLastCount = array_length(un_MatchOnLast), fl_CountForLast, Type;\nlet char4 = First4charList | join Last4charList on CharSet and TimeGenerated\n| project-away TimeGenerated1, CharSet1\n// Make sure that we get more than a single match for First or Last\n| where un_MatchOnFirstCount >= un_MatchMin or un_MatchOnLastCount >= un_MatchMin\n| where fl_CountForFirst >= fl_Min or fl_CountForLast >= fl_Min;\nlet Char6List = UserNameList\n| project TimeGenerated, First6char, Last6char, UserNames, fl_Count, Type\n| where First6char != \"LessThan6\" and Last6char != \"LessThan6\";\n// Break out first and last so we can then join and see where a first and last match.\nlet First6charList = Char6List | where isnotempty(First6char)\n| summarize un_MatchOnFirst = makeset(UserNames), fl_CountForFirst = sum(fl_Count) by TimeGenerated, CharSet = First6char, Type\n| project TimeGenerated, CharSet, un_MatchOnFirst, un_MatchOnFirstCount = array_length(un_MatchOnFirst), fl_CountForFirst, Type;\nlet Last6charList = Char6List | where isnotempty(Last6char)\n| summarize un_MatchOnLast = makeset(UserNames), fl_CountForLast = sum(fl_Count) by TimeGenerated, CharSet = Last6char, Type\n| project TimeGenerated, CharSet, un_MatchOnLast, un_MatchOnLastCount = array_length(un_MatchOnLast), fl_CountForLast, Type;\nlet char6 = First6charList | join Last6charList on CharSet and TimeGenerated\n| project-away TimeGenerated1, CharSet1\n// Make sure that we get more than a single match for First or Last\n| where un_MatchOnFirstCount >= un_MatchMin or un_MatchOnLastCount >= un_MatchMin\n| where fl_CountForFirst >= fl_Min or fl_CountForLast >= fl_Min;\nlet Char8List = UserNameList\n| project TimeGenerated, First8char, Last8char, UserNames, fl_Count, Type\n| where First8char != \"LessThan8\" and Last8char != \"LessThan8\";\n// Break out first and last so we can then join and see where a first and last match.\nlet First8charList = Char8List | where isnotempty(First8char)\n| summarize un_MatchOnFirst = makeset(UserNames), fl_CountForFirst = sum(fl_Count) by TimeGenerated, CharSet = First8char, Type\n| project TimeGenerated, CharSet, un_MatchOnFirst, un_MatchOnFirstCount = array_length(un_MatchOnFirst), fl_CountForFirst, Type; \nlet Last8charList = Char8List | where isnotempty(Last8char)\n| summarize un_MatchOnLast = makeset(UserNames), fl_CountForLast = sum(fl_Count) by TimeGenerated, CharSet = Last8char, Type\n| project TimeGenerated, CharSet, un_MatchOnLast, un_MatchOnLastCount = array_length(un_MatchOnLast), fl_CountForLast, Type;\nlet char8 = First8charList | join Last8charList on CharSet and TimeGenerated\n| project-away TimeGenerated1, CharSet1\n// Make sure that we get more than a single match for First or Last\n| where un_MatchOnFirstCount >= un_MatchMin or un_MatchOnLastCount >= un_MatchMin\n| where fl_CountForFirst >= fl_Min or fl_CountForLast >= fl_Min;\n(union isfuzzy=true char4, char6, char8)\n| project Type, TimeGenerated, CharSet, UserNameMatchOnFirst = un_MatchOnFirst, UserNameMatchOnFirstCount = un_MatchOnFirstCount,\nFailedLogonCountForFirst = fl_CountForFirst, UserNameMatchOnLast = un_MatchOnLast, UserNameMatchOnLastCount = un_MatchOnLastCount,\nFailedLogonCountForLast = fl_CountForLast\n| sort by UserNameMatchOnFirstCount desc, UserNameMatchOnLastCount desc\n| extend timestamp = TimeGenerated"
SeveritiesFilter: 
Severity: Medium
QueryFrequency: PT5M
QueryPeriod: PT5M
TriggerOperator: GreaterThan
TriggerThreshold: 0
Tactics:
- InitialAccess
EventGroupSettings: 
SuppressionDuration: PT1H
SuppressionEnabled: false
IncidentConfiguration:
  createIncident: true
  groupingConfiguration:
    enabled: false
    reopenClosedIncident: false
    lookbackDuration: PT5M
    entitiesMatchingMethod: All
    groupByEntities: []
EntityMappings: 
Kind: Scheduled
